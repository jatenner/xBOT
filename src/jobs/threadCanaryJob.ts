/**
 * üßµ THREAD CANARY JOB
 * Ensures threads are posted periodically for reliability verification
 * Runs every 60 minutes and enqueues a thread if none posted in last 12 hours
 */

import { getSupabaseClient } from '../db/index';
import { v4 as uuidv4 } from 'uuid';
import { log } from '../lib/logger';

const CANARY_INTERVAL_MS = 60 * 60 * 1000; // 60 minutes
const THREAD_STALENESS_THRESHOLD_MS = 12 * 60 * 60 * 1000; // 12 hours

interface ThreadCanaryResult {
  action: 'enqueued' | 'skipped';
  reason: string;
  lastThreadPostedAt?: string;
}

export async function runThreadCanary(): Promise<ThreadCanaryResult> {
  try {
    const supabase = getSupabaseClient();
    
    // Check last successfully posted thread
    const { data: lastThread, error: threadError } = await supabase
      .from('content_metadata')
      .select('posted_at')
      .eq('decision_type', 'thread')
      .eq('status', 'posted')
      .not('posted_at', 'is', null)
      .order('posted_at', { ascending: false })
      .limit(1)
      .single();
    
    if (threadError && threadError.code !== 'PGRST116') { // PGRST116 = no rows
      console.error(`[THREAD_CANARY] ‚ùå Error checking last thread: ${threadError.message}`);
      return { action: 'skipped', reason: `Database error: ${threadError.message}` };
    }
    
    const lastThreadPostedAt = lastThread?.posted_at || null;
    const now = new Date();
    const lastThreadTime = lastThreadPostedAt ? new Date(lastThreadPostedAt) : null;
    const hoursSinceLastThread = lastThreadTime 
      ? (now.getTime() - lastThreadTime.getTime()) / (60 * 60 * 1000)
      : Infinity;
    
    // Check if queue has threads ready
    const { data: queuedThreads, error: queueError } = await supabase
      .from('content_metadata')
      .select('decision_id')
      .eq('decision_type', 'thread')
      .eq('status', 'queued')
      .limit(1);
    
    if (queueError) {
      console.error(`[THREAD_CANARY] ‚ùå Error checking queue: ${queueError.message}`);
      return { action: 'skipped', reason: `Queue check error: ${queueError.message}` };
    }
    
    const hasQueuedThreads = (queuedThreads?.length || 0) > 0;
    
    // Decision logic
    if (hasQueuedThreads) {
      console.log(`[THREAD_CANARY] ‚è≠Ô∏è Skipped: Queue already has ${queuedThreads?.length} thread(s) ready`);
      return { 
        action: 'skipped', 
        reason: `Queue has ${queuedThreads?.length} thread(s) ready`,
        lastThreadPostedAt: lastThreadPostedAt || undefined
      };
    }
    
    if (lastThreadTime && hoursSinceLastThread < 12) {
      console.log(`[THREAD_CANARY] ‚è≠Ô∏è Skipped: Last thread posted ${hoursSinceLastThread.toFixed(1)}h ago (< 12h threshold)`);
      return { 
        action: 'skipped', 
        reason: `Last thread posted ${hoursSinceLastThread.toFixed(1)}h ago`,
        lastThreadPostedAt: lastThreadPostedAt
      };
    }
    
    // Enqueue a safe thread decision
    const decisionId = uuidv4();
    const safeSlot = 'framework'; // Safe, educational slot
    
    // Generate minimal thread content (will be replaced by planJob if needed, but ensures thread format)
    const threadParts = [
      'üßµ Thread canary: Ensuring thread posting reliability...',
      'This thread was auto-generated by the thread canary job to verify THREAD_COMPOSER instrumentation.',
      'The system will learn from this thread\'s performance and continue monitoring thread posting health.'
    ];
    
    const { error: insertError } = await supabase
      .from('content_metadata')
      .insert([{
        decision_id: decisionId,
        decision_type: 'thread',
        content: threadParts[0], // First part as main content
        thread_parts: threadParts,
        content_slot: safeSlot,
        generation_source: 'canary',
        status: 'queued',
        scheduled_at: new Date().toISOString(),
        generator_name: 'thoughtLeader',
        quality_score: 0.75,
        predicted_er: 0.025,
        topic_cluster: 'system_reliability',
        angle: 'educational',
        tone: 'informative'
      }]);
    
    if (insertError) {
      console.error(`[THREAD_CANARY] ‚ùå Failed to enqueue thread: ${insertError.message}`);
      return { 
        action: 'skipped', 
        reason: `Insert failed: ${insertError.message}`,
        lastThreadPostedAt: lastThreadPostedAt || undefined
      };
    }
    
    console.log(`[THREAD_CANARY] ‚úÖ Enqueued thread decision ${decisionId} (slot=${safeSlot}, lastThread=${lastThreadPostedAt || 'never'})`);
    log({ 
      op: 'thread_canary', 
      action: 'enqueued', 
      decision_id: decisionId,
      last_thread_hours_ago: lastThreadTime ? hoursSinceLastThread : null
    });
    
    return { 
      action: 'enqueued', 
      reason: `No threads in queue and last thread was ${lastThreadPostedAt ? `${hoursSinceLastThread.toFixed(1)}h ago` : 'never'}`,
      lastThreadPostedAt: lastThreadPostedAt || undefined
    };
    
  } catch (error: any) {
    console.error(`[THREAD_CANARY] ‚ùå Fatal error: ${error.message}`);
    return { action: 'skipped', reason: `Fatal error: ${error.message}` };
  }
}

