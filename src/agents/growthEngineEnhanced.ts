/**
 * ENHANCED GROWTH ENGINE FOR PRODUCTION xBOT
 * 
 * Integrates the Human-Grade Growth Engine with your existing sophisticated xBOT system
 * - Works with current autonomous posting engine
 * - Handles login failures gracefully
 * - Uses existing database connections
 * - Maintains your viral content strategies
 * - Adds human-grade quality control
 */

import { HumanGradeGrowthEngine, GrowthEngineInput, GrowthEngineOutput } from './humanGradeGrowthEngine';
import { GrowthEngineIntegrationSimple } from './growthEngineIntegrationSimple';

export interface ProductionGrowthConfig {
  useGrowthEngine: boolean;
  fallbackToExisting: boolean;
  minOpportunityScore: number;
  maxDailyPosts: number;
  debugMode: boolean;
}

export class EnhancedGrowthEngine {
  private static instance: EnhancedGrowthEngine;
  private growthEngine: HumanGradeGrowthEngine;
  private simpleIntegration: GrowthEngineIntegrationSimple;
  private config: ProductionGrowthConfig;

  private constructor() {
    this.growthEngine = HumanGradeGrowthEngine.getInstance();
    this.simpleIntegration = GrowthEngineIntegrationSimple.getInstance();
    this.config = {
      useGrowthEngine: process.env.USE_GROWTH_ENGINE === 'true',
      fallbackToExisting: true,
      minOpportunityScore: 0.6,
      maxDailyPosts: 25,
      debugMode: process.env.NODE_ENV !== 'production'
    };
  }

  public static getInstance(): EnhancedGrowthEngine {
    if (!EnhancedGrowthEngine.instance) {
      EnhancedGrowthEngine.instance = new EnhancedGrowthEngine();
    }
    return EnhancedGrowthEngine.instance;
  }

  /**
   * Enhanced posting decision that integrates with existing xBOT logic
   */
  public async shouldPost(context: {
    opportunityScore: number;
    timeContext: string;
    lastPostMinutes: number;
    dailyPostCount: number;
  }): Promise<{
    shouldPost: boolean;
    useGrowthEngine: boolean;
    reason: string;
    growthDecision?: GrowthEngineOutput;
  }> {
    
    console.log('üß† Enhanced Growth Engine: Analyzing posting decision...');
    
    // Check if growth engine is enabled
    if (!this.config.useGrowthEngine) {
      return {
        shouldPost: true,
        useGrowthEngine: false,
        reason: 'Growth engine disabled, using existing logic'
      };
    }

    try {
      // Create input for growth engine using current context
      const input = this.createInputFromContext(context);
      
      // Get growth engine recommendation
      const growthDecision = await this.growthEngine.processGrowthDecision(input);
      
      console.log(`üéØ Growth Engine Decision: ${growthDecision.post_now ? 'POST' : 'DEFER'}`);
      console.log(`üìä Opportunity Score: ${growthDecision.decision.pacing.opportunity.toFixed(2)}`);
      console.log(`üé≠ Format: ${growthDecision.decision.format} | Topic: ${growthDecision.decision.topic}`);
      
      // Use growth engine decision if opportunity score is high enough
      if (growthDecision.post_now && growthDecision.decision.pacing.opportunity >= this.config.minOpportunityScore) {
        return {
          shouldPost: true,
          useGrowthEngine: true,
          reason: `High growth opportunity (${growthDecision.decision.pacing.opportunity.toFixed(2)})`,
          growthDecision
        };
      }
      
      // If growth engine says no but existing system says yes, use existing
      if (!growthDecision.post_now && this.config.fallbackToExisting && context.opportunityScore > 30) {
        return {
          shouldPost: true,
          useGrowthEngine: false,
          reason: 'Growth engine deferred, falling back to existing logic'
        };
      }
      
      return {
        shouldPost: false,
        useGrowthEngine: true,
        reason: growthDecision.reason,
        growthDecision
      };
      
    } catch (error) {
      console.error('‚ùå Growth engine error, falling back to existing logic:', error.message);
      
      if (this.config.fallbackToExisting) {
        return {
          shouldPost: true,
          useGrowthEngine: false,
          reason: 'Growth engine error, using existing logic'
        };
      }
      
      return {
        shouldPost: false,
        useGrowthEngine: false,
        reason: 'Growth engine error and no fallback'
      };
    }
  }

  /**
   * Generate content using growth engine
   */
  public async generateContent(growthDecision: GrowthEngineOutput): Promise<{
    content: string;
    isThread: boolean;
    threadParts?: string[];
    metadata: any;
  }> {
    
    if (!growthDecision.draft.tweets || growthDecision.draft.tweets.length === 0) {
      throw new Error('No content generated by growth engine');
    }

    const isThread = growthDecision.decision.format === 'thread' && growthDecision.draft.tweets.length > 1;
    
    if (isThread) {
      return {
        content: growthDecision.draft.tweets[0].text,
        isThread: true,
        threadParts: growthDecision.draft.tweets.map(t => t.text),
        metadata: {
          topic: growthDecision.decision.topic,
          pillar: growthDecision.decision.pillar,
          persona: growthDecision.decision.persona,
          hookType: growthDecision.decision.hook_type,
          qualityScore: growthDecision.qc.human_vibe_score,
          sources: growthDecision.draft.sources
        }
      };
    } else {
      return {
        content: growthDecision.draft.tweets[0].text,
        isThread: false,
        metadata: {
          topic: growthDecision.decision.topic,
          pillar: growthDecision.decision.pillar,
          persona: growthDecision.decision.persona,
          hookType: growthDecision.decision.hook_type,
          qualityScore: growthDecision.qc.human_vibe_score,
          sources: growthDecision.draft.sources
        }
      };
    }
  }

  /**
   * Create growth engine input from current xBOT context
   */
  private createInputFromContext(context: any): GrowthEngineInput {
    const now = new Date();
    const hour = now.getHours();
    
    // Map your existing opportunity score to EPM metrics
    const epmCurrent = Math.max(0.1, context.opportunityScore / 100);
    const epmEwma = epmCurrent * 0.8;
    
    return {
      now_local: now.toISOString(),
      caps: {
        max_day: this.config.maxDailyPosts,
        max_hour: 6,
        min_gap: 30,
        min_gap_same: 120,
        thread_cooldown: 60,
        min_posts_per_2h: 1
      },
      recent_counts: {
        hour: Math.floor(context.dailyPostCount / 24),
        day: context.dailyPostCount,
        last_post_min_ago: context.lastPostMinutes,
        last_format: "single",
        since_last_2h: Math.floor(context.dailyPostCount / 12)
      },
      followers: this.estimateFollowerCount(),
      metrics: {
        epm_current: epmCurrent,
        epm_ewma: epmEwma,
        format_bandit: {
          single: 0.3,
          thread: 0.4, // Favor threads since your system is good at them
          reply: 0.1,
          quote: 0.1,
          longform_single: 0.1
        },
        persona_hook_bandit: {
          "Scientist/myth_bust": 0.25,
          "Coach/how_to": 0.35, // Your system seems coach-like
          "Storyteller/story": 0.15,
          "Curator/checklist": 0.15,
          "Mythbuster/checklist": 0.1
        }
      },
      fatigue: {
        format_streak: 1,
        thread_cooldown_remaining: 0
      },
      twitter_trends: this.getHealthTrends(),
      news_trends: [],
      trend_policy: {
        fit_min: 0.35,
        prefer_twitter_over_news: true,
        max_offtopic_ratio: 0.15,
        blacklist: ["politics", "war", "nsfw", "celebrity_scandal"]
      },
      recent_posts_text: [],
      limits: {
        first_visible_chars: 240,
        tweet_max_hard: 275,
        longform_max_chars: 9000
      },
      style: {
        style_jitter: 0.25,
        hedge_prob: 0.15,
        question_prob: 0.25,
        emoji_max: 1,
        no_hashtags: true
      },
      capabilities: {
        longform_available: false, // Conservative default
        replies_allowed: true,
        quotes_allowed: true
      },
      reply_context: {
        gist: null,
        author: null
      }
    };
  }

  /**
   * Estimate follower count (you can connect to your analytics)
   */
  private estimateFollowerCount(): number {
    // Default estimate - replace with actual follower count from your analytics
    return 50;
  }

  /**
   * Get health-related trending topics
   */
  private getHealthTrends() {
    const baseHealthTrends = [
      { phrase: "mental health awareness", momentum: 0.7, tph: 120, category: "Health" as const },
      { phrase: "sleep quality", momentum: 0.6, tph: 95, category: "Sleep" as const },
      { phrase: "stress management", momentum: 0.5, tph: 80, category: "Stress" as const },
      { phrase: "wellness tips", momentum: 0.4, tph: 60, category: "Health" as const }
    ];

    // Add some randomization to momentum
    return baseHealthTrends.map(trend => ({
      ...trend,
      momentum: Math.min(1.0, trend.momentum + (Math.random() - 0.5) * 0.2)
    }));
  }

  /**
   * Get system status
   */
  public getStatus() {
    return {
      enabled: this.config.useGrowthEngine,
      config: this.config,
      lastCheck: new Date().toISOString()
    };
  }

  /**
   * Update configuration
   */
  public updateConfig(updates: Partial<ProductionGrowthConfig>) {
    this.config = { ...this.config, ...updates };
    console.log('üîß Growth engine config updated:', this.config);
  }
}

/**
 * Quick integration function for existing autonomous posting engine
 */
export async function enhancePostingDecision(context: {
  opportunityScore: number;
  timeContext: string;
  lastPostMinutes: number;
  dailyPostCount: number;
}): Promise<{
  shouldPost: boolean;
  useGrowthEngine: boolean;
  reason: string;
  content?: {
    content: string;
    isThread: boolean;
    threadParts?: string[];
    metadata: any;
  };
}> {
  
  const enhancedEngine = EnhancedGrowthEngine.getInstance();
  const decision = await enhancedEngine.shouldPost(context);
  
  if (decision.shouldPost && decision.useGrowthEngine && decision.growthDecision) {
    try {
      const content = await enhancedEngine.generateContent(decision.growthDecision);
      return {
        ...decision,
        content
      };
    } catch (error) {
      console.error('‚ùå Failed to generate growth engine content:', error.message);
      return decision;
    }
  }
  
  return decision;
}

/**
 * Test the enhanced growth engine
 */
export async function testEnhancedGrowthEngine() {
  console.log('üß™ Testing Enhanced Growth Engine Integration...');
  
  const context = {
    opportunityScore: 75,
    timeContext: "Prime engagement window",
    lastPostMinutes: 90,
    dailyPostCount: 3
  };
  
  const result = await enhancePostingDecision(context);
  
  console.log('üìä Enhanced Growth Engine Test Results:');
  console.log('- Should post:', result.shouldPost);
  console.log('- Use growth engine:', result.useGrowthEngine);
  console.log('- Reason:', result.reason);
  
  if (result.content) {
    console.log('- Content preview:', result.content.content.substring(0, 100) + '...');
    console.log('- Is thread:', result.content.isThread);
    console.log('- Quality score:', result.content.metadata.qualityScore);
  }
  
  return result;
}