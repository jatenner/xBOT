/**
 * ENHANCED GROWTH ENGINE FOR PRODUCTION xBOT
 * 
 * Integrates the Human-Grade Growth Engine with your existing sophisticated xBOT system
 * - Works with current autonomous posting engine
 * - Handles login failures gracefully
 * - Uses existing database connections
 * - Maintains your viral content strategies
 * - Adds human-grade quality control
 */

import { HumanGradeGrowthEngine, GrowthEngineInput, GrowthEngineOutput } from './humanGradeGrowthEngine';
import { GrowthEngineIntegrationSimple } from './growthEngineIntegrationSimple';
import { validateThread, ThreadDraft, ThreadValidationResult, generateStrictThreadPrompt } from '../utils/threadValidator';
import { loadBotConfig } from '../config';

export interface ProductionGrowthConfig {
  useGrowthEngine: boolean;
  fallbackToExisting: boolean;
  minOpportunityScore: number;
  maxDailyPosts: number;
  debugMode: boolean;
}

export class EnhancedGrowthEngine {
  private static instance: EnhancedGrowthEngine;
  private growthEngine: HumanGradeGrowthEngine;
  private simpleIntegration: GrowthEngineIntegrationSimple;
  private config: ProductionGrowthConfig;

  private constructor() {
    this.growthEngine = HumanGradeGrowthEngine.getInstance();
    this.simpleIntegration = GrowthEngineIntegrationSimple.getInstance();
    this.config = {
      useGrowthEngine: process.env.USE_GROWTH_ENGINE === 'true',
      fallbackToExisting: true,
      minOpportunityScore: 0.6,
      maxDailyPosts: 25,
      debugMode: process.env.NODE_ENV !== 'production'
    };
  }

  public static getInstance(): EnhancedGrowthEngine {
    if (!EnhancedGrowthEngine.instance) {
      EnhancedGrowthEngine.instance = new EnhancedGrowthEngine();
    }
    return EnhancedGrowthEngine.instance;
  }

  /**
   * Enhanced posting decision that integrates with existing xBOT logic
   */
  public async shouldPost(context: {
    opportunityScore: number;
    timeContext: string;
    lastPostMinutes: number;
    dailyPostCount: number;
  }): Promise<{
    shouldPost: boolean;
    useGrowthEngine: boolean;
    reason: string;
    growthDecision?: GrowthEngineOutput;
  }> {
    
    console.log('üß† Enhanced Growth Engine: Analyzing posting decision...');
    
    // Check if growth engine is enabled
    if (!this.config.useGrowthEngine) {
      return {
        shouldPost: true,
        useGrowthEngine: false,
        reason: 'Growth engine disabled, using existing logic'
      };
    }

    try {
      // Create input for growth engine using current context
      const input = this.createInputFromContext(context);
      
      // Get growth engine recommendation
      const growthDecision = await this.growthEngine.processGrowthDecision(input);
      
      console.log(`üéØ Growth Engine Decision: ${growthDecision.post_now ? 'POST' : 'DEFER'}`);
      console.log(`üìä Opportunity Score: ${growthDecision.decision.pacing.opportunity.toFixed(2)}`);
      console.log(`üé≠ Format: ${growthDecision.decision.format} | Topic: ${growthDecision.decision.topic}`);
      
      // Use growth engine decision if opportunity score is high enough
      if (growthDecision.post_now && growthDecision.decision.pacing.opportunity >= this.config.minOpportunityScore) {
        return {
          shouldPost: true,
          useGrowthEngine: true,
          reason: `High growth opportunity (${growthDecision.decision.pacing.opportunity.toFixed(2)})`,
          growthDecision
        };
      }
      
      // If growth engine says no but existing system says yes, use existing
      if (!growthDecision.post_now && this.config.fallbackToExisting && context.opportunityScore > 30) {
        return {
          shouldPost: true,
          useGrowthEngine: false,
          reason: 'Growth engine deferred, falling back to existing logic'
        };
      }
      
      return {
        shouldPost: false,
        useGrowthEngine: true,
        reason: growthDecision.reason,
        growthDecision
      };
      
    } catch (error) {
      console.error('‚ùå Growth engine error, falling back to existing logic:', error.message);
      
      if (this.config.fallbackToExisting) {
        return {
          shouldPost: true,
          useGrowthEngine: false,
          reason: 'Growth engine error, using existing logic'
        };
      }
      
      return {
        shouldPost: false,
        useGrowthEngine: false,
        reason: 'Growth engine error and no fallback'
      };
    }
  }

  /**
   * Generate content using growth engine with strict thread validation and retry
   */
  public async generateContent(growthDecision: GrowthEngineOutput): Promise<{
    content: string;
    isThread: boolean;
    threadParts?: string[];
    metadata: any;
  }> {
    
    if (!growthDecision.draft.tweets || growthDecision.draft.tweets.length === 0) {
      throw new Error('No content generated by growth engine');
    }

    const wantedFormat = growthDecision.decision.format;
    console.log(`FORMAT_DECISION: want=${wantedFormat}, initial_tweets=${growthDecision.draft.tweets.length}`);

    // If format decision is thread, enforce strict thread requirements
    if (wantedFormat === 'thread') {
      const validatedThread = await this.ensureThreadOrRegenerate(growthDecision);
      
      if (validatedThread) {
        console.log(`FORMAT_DECISION: final=thread, tweets=${validatedThread.tweets.length}`);
        return {
          content: validatedThread.tweets[0],
          isThread: true,
          threadParts: validatedThread.tweets,
          metadata: {
            topic: growthDecision.decision.topic,
            pillar: growthDecision.decision.pillar,
            persona: growthDecision.decision.persona,
            hookType: growthDecision.decision.hook_type,
            qualityScore: growthDecision.qc.human_vibe_score,
            sources: growthDecision.draft.sources
          }
        };
      } else {
        // Thread generation failed after retries
        const config = await loadBotConfig();
        if (config.fallbackSingleTweetOk) {
          console.log('THREAD_FALLBACK: to=single (allowed=true)');
          return {
            content: growthDecision.draft.tweets[0].text,
            isThread: false,
            metadata: {
              topic: growthDecision.decision.topic,
              pillar: growthDecision.decision.pillar,
              persona: growthDecision.decision.persona,
              hookType: growthDecision.decision.hook_type,
              qualityScore: growthDecision.qc.human_vibe_score,
              sources: growthDecision.draft.sources
            }
          };
        } else {
          console.log('THREAD_SKIP: fallback=false reason=invalid_thread');
          throw new Error('THREAD_GENERATION_FAILED: Unable to generate valid thread after retries and fallback disabled');
        }
      }
    } else {
      // Single or longform_single format
      console.log(`FORMAT_DECISION: final=${wantedFormat}, tweets=1`);
      return {
        content: growthDecision.draft.tweets[0].text,
        isThread: false,
        metadata: {
          topic: growthDecision.decision.topic,
          pillar: growthDecision.decision.pillar,
          persona: growthDecision.decision.persona,
          hookType: growthDecision.decision.hook_type,
          qualityScore: growthDecision.qc.human_vibe_score,
          sources: growthDecision.draft.sources
        }
      };
    }
  }

  /**
   * Ensure thread meets requirements or regenerate with retry logic
   */
  private async ensureThreadOrRegenerate(growthDecision: GrowthEngineOutput): Promise<{ tweets: string[] } | null> {
    const config = await loadBotConfig();
    const threadDraft: ThreadDraft = { tweets: growthDecision.draft.tweets };
    
    // First validation attempt with the original content
    const validation = validateThread(threadDraft);
    
    if (validation.ok && validation.repairedTweets) {
      console.log(`THREAD_VALIDATE: k=${validation.repairedTweets.length} OK (first_attempt)`);
      return { tweets: validation.repairedTweets };
    }
    
    // Thread failed validation, start retry loop
    console.log(`THREAD_VALIDATE: k=${validation.k || threadDraft.tweets.length} < min=${config.threadMinTweets} ‚Üí REASK(1/${config.threadRetryAttempts})`);
    
    for (let attempt = 1; attempt <= config.threadRetryAttempts; attempt++) {
      try {
        // Add jittered backoff
        if (attempt > 1) {
          const delay = config.threadRetryBaseMs + Math.random() * config.threadRetryBaseMs;
          await new Promise(resolve => setTimeout(resolve, delay));
        }
        
        // Generate strict thread prompt
        const topic = `${growthDecision.decision.topic} (${growthDecision.decision.persona} style)`;
        const strictPrompt = generateStrictThreadPrompt(
          topic, 
          config.threadMinTweets, 
          config.threadMaxTweets, 
          config.tweetMaxCharsHard
        );
        
        // Call the growth engine with strict constraints
        console.log(`THREAD_REASK: attempt=${attempt}/${config.threadRetryAttempts} topic="${topic.substring(0, 50)}..."`);
        
        // Create a modified input that forces thread generation
        const baseInput = this.createInputFromContext({ 
          opportunityScore: 80,
          dailyPostCount: 5,
          lastPostMinutes: 60
        });
        
        // Override the format bandits to force thread selection
        baseInput.metrics.format_bandit.thread = 1.0;
        baseInput.metrics.format_bandit.single = 0.0;
        baseInput.metrics.format_bandit.reply = 0.0;
        baseInput.metrics.format_bandit.quote = 0.0;
        baseInput.metrics.format_bandit.longform_single = 0.0;
        
        // Force thread parameters
        baseInput.caps.max_day = 100; // Remove daily limits for retry
        baseInput.recent_counts.hour = 0; // Reset counts
        
        const retryResult = await this.growthEngine.generateContent(baseInput);
        
        if (retryResult.draft.tweets && retryResult.draft.tweets.length >= config.threadMinTweets) {
          const retryValidation = validateThread({ tweets: retryResult.draft.tweets });
          
          if (retryValidation.ok && retryValidation.repairedTweets) {
            console.log(`THREAD_VALIDATE: k=${retryValidation.repairedTweets.length} OK (attempt=${attempt})`);
            return { tweets: retryValidation.repairedTweets };
          } else {
            console.log(`THREAD_VALIDATE: k=${retryValidation.k || retryResult.draft.tweets.length} failed ‚Üí reason=${retryValidation.reason} (attempt=${attempt})`);
          }
        } else {
          console.log(`THREAD_VALIDATE: k=${retryResult.draft.tweets?.length || 0} < min=${config.threadMinTweets} (attempt=${attempt})`);
        }
        
      } catch (error: any) {
        console.log(`THREAD_REASK: attempt=${attempt} failed ‚Üí error=${error.message}`);
      }
    }
    
    // All retry attempts failed
    console.log(`THREAD_GEN_FAIL: reason=too_short attempt=${config.threadRetryAttempts}/${config.threadRetryAttempts}`);
    return null;
  }

  /**
   * Create growth engine input from current xBOT context
   */
  private createInputFromContext(context: any): GrowthEngineInput {
    const now = new Date();
    const hour = now.getHours();
    
    // Map your existing opportunity score to EPM metrics
    const epmCurrent = Math.max(0.1, context.opportunityScore / 100);
    const epmEwma = epmCurrent * 0.8;
    
    return {
      now_local: now.toISOString(),
      caps: {
        max_day: this.config.maxDailyPosts,
        max_hour: 6,
        min_gap: 30,
        min_gap_same: 120,
        thread_cooldown: 60,
        min_posts_per_2h: 1
      },
      recent_counts: {
        hour: Math.floor(context.dailyPostCount / 24),
        day: context.dailyPostCount,
        last_post_min_ago: context.lastPostMinutes,
        last_format: "single",
        since_last_2h: Math.floor(context.dailyPostCount / 12)
      },
      followers: this.estimateFollowerCount(),
      metrics: {
        epm_current: epmCurrent,
        epm_ewma: epmEwma,
        format_bandit: {
          single: 0.3,
          thread: 0.4, // Favor threads since your system is good at them
          reply: 0.1,
          quote: 0.1,
          longform_single: 0.1
        },
        persona_hook_bandit: {
          "Scientist/myth_bust": 0.25,
          "Coach/how_to": 0.35, // Your system seems coach-like
          "Storyteller/story": 0.15,
          "Curator/checklist": 0.15,
          "Mythbuster/checklist": 0.1
        }
      },
      fatigue: {
        format_streak: 1,
        thread_cooldown_remaining: 0
      },
      twitter_trends: this.getHealthTrends(),
      news_trends: [],
      trend_policy: {
        fit_min: 0.35,
        prefer_twitter_over_news: true,
        max_offtopic_ratio: 0.15,
        blacklist: ["politics", "war", "nsfw", "celebrity_scandal"]
      },
      recent_posts_text: [],
      limits: {
        first_visible_chars: 240,
        tweet_max_hard: 275,
        longform_max_chars: 9000
      },
      style: {
        style_jitter: 0.25,
        hedge_prob: 0.15,
        question_prob: 0.25,
        emoji_max: 1,
        no_hashtags: true
      },
      capabilities: {
        longform_available: false, // Conservative default
        replies_allowed: true,
        quotes_allowed: true
      },
      reply_context: {
        gist: null,
        author: null
      }
    };
  }

  /**
   * Estimate follower count (you can connect to your analytics)
   */
  private estimateFollowerCount(): number {
    // Default estimate - replace with actual follower count from your analytics
    return 50;
  }

  /**
   * Get health-related trending topics
   */
  private getHealthTrends() {
    const baseHealthTrends = [
      { phrase: "mental health awareness", momentum: 0.7, tph: 120, category: "Health" as const },
      { phrase: "sleep quality", momentum: 0.6, tph: 95, category: "Sleep" as const },
      { phrase: "stress management", momentum: 0.5, tph: 80, category: "Stress" as const },
      { phrase: "wellness tips", momentum: 0.4, tph: 60, category: "Health" as const }
    ];

    // Add some randomization to momentum
    return baseHealthTrends.map(trend => ({
      ...trend,
      momentum: Math.min(1.0, trend.momentum + (Math.random() - 0.5) * 0.2)
    }));
  }

  /**
   * Get system status
   */
  public getStatus() {
    return {
      enabled: this.config.useGrowthEngine,
      config: this.config,
      lastCheck: new Date().toISOString()
    };
  }

  /**
   * Update configuration
   */
  public updateConfig(updates: Partial<ProductionGrowthConfig>) {
    this.config = { ...this.config, ...updates };
    console.log('üîß Growth engine config updated:', this.config);
  }
}

/**
 * Quick integration function for existing autonomous posting engine
 */
export async function enhancePostingDecision(context: {
  opportunityScore: number;
  timeContext: string;
  lastPostMinutes: number;
  dailyPostCount: number;
}): Promise<{
  shouldPost: boolean;
  useGrowthEngine: boolean;
  reason: string;
  content?: {
    content: string;
    isThread: boolean;
    threadParts?: string[];
    metadata: any;
  };
}> {
  
  const enhancedEngine = EnhancedGrowthEngine.getInstance();
  const decision = await enhancedEngine.shouldPost(context);
  
  if (decision.shouldPost && decision.useGrowthEngine && decision.growthDecision) {
    try {
      const content = await enhancedEngine.generateContent(decision.growthDecision);
      return {
        ...decision,
        content
      };
    } catch (error) {
      console.error('‚ùå Failed to generate growth engine content:', error.message);
      return decision;
    }
  }
  
  return decision;
}

/**
 * Test the enhanced growth engine
 */
export async function testEnhancedGrowthEngine() {
  console.log('üß™ Testing Enhanced Growth Engine Integration...');
  
  const context = {
    opportunityScore: 75,
    timeContext: "Prime engagement window",
    lastPostMinutes: 90,
    dailyPostCount: 3
  };
  
  const result = await enhancePostingDecision(context);
  
  console.log('üìä Enhanced Growth Engine Test Results:');
  console.log('- Should post:', result.shouldPost);
  console.log('- Use growth engine:', result.useGrowthEngine);
  console.log('- Reason:', result.reason);
  
  if (result.content) {
    console.log('- Content preview:', result.content.content.substring(0, 100) + '...');
    console.log('- Is thread:', result.content.isThread);
    console.log('- Quality score:', result.content.metadata.qualityScore);
  }
  
  return result;
}