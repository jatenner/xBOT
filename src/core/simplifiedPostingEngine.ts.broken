/**
 * SIMPLIFIED POSTING ENGINE - Emergency Fix
 * 
 * This replaces the over-complex autonomous posting system with a simple,
 * reliable posting mechanism focused on actual engagement results.
 */

// LEGACY: postThread.ts deleted - this file is broken/archived
// import { TwitterPoster } from '../posting/postThread';
import { getContentGenerator } from '../ai/generate';
import { validateContent } from '../quality/qualityGate';
import { scheduleMetricsTracking } from '../metrics/trackTweet';
import { storeLearningPost } from '../db/index';
import { logInfo, logError } from '../utils/intelligentLogging';
import { ContentQualityController } from '../quality/contentQualityController';
import { ContentPerformanceLearner } from '../learning/contentPerformanceLearner';
import { TwitterAnalyticsScraper } from '../analytics/twitterAnalyticsScraper';
import { DeepContentGenerator } from '../ai/deepContentGenerator';

export interface SimplePostResult {
  success: boolean;
  tweetId?: string;
  content?: string;
  error?: string;
  engagementPrediction?: number;
}

export class SimplifiedPostingEngine {
  private static instance: SimplifiedPostingEngine;
  private isPosting = false;
  private lastPostTime = 0;
  private readonly MIN_POST_INTERVAL = 60 * 60 * 1000; // 60 minutes for growth
  private readonly MAX_DAILY_POSTS = 20; // Increased for small account growth
  private recentFailures: number[] = []; // Track failure timestamps for circuit breaker
  private dailyPostCount = 0;
  private lastResetDate = new Date().toDateString();
  private qualityController: ContentQualityController;
  private learner: ContentPerformanceLearner;
  private analyticsScraper: TwitterAnalyticsScraper;
  private deepGenerator: DeepContentGenerator;

  private constructor() {
    this.qualityController = new ContentQualityController(process.env.OPENAI_API_KEY!);
    this.learner = ContentPerformanceLearner.getInstance();
    this.analyticsScraper = new TwitterAnalyticsScraper();
    this.deepGenerator = new DeepContentGenerator(process.env.OPENAI_API_KEY!);
  }

  public static getInstance(): SimplifiedPostingEngine {
    if (!SimplifiedPostingEngine.instance) {
      SimplifiedPostingEngine.instance = new SimplifiedPostingEngine();
    }
    return SimplifiedPostingEngine.instance;
  }

  /**
   * Simple, reliable posting with engagement optimization
   */
  /**
   * REAL-TIME DATA DRIVEN DECISIONS: Use analytics to inform content strategy
   */
  async getDataDrivenContentStrategy(): Promise<{
    shouldPost: boolean;
    contentHints: string[];
    engagementTarget: number;
    topPerformingPatterns: string[];
  }> {
    try {
      console.log('üìä DATA_DRIVEN_STRATEGY: Analyzing real Twitter data...');

      // Get fresh analytics insights
      const insights = await this.analyticsScraper.getAnalyticsInsights();
      
      // Get recent performance data  
      const recentAnalytics = await this.analyticsScraper.scrapeAllAnalytics();
      
      const contentHints: string[] = [];
      const topPerformingPatterns: string[] = [];

      // Analyze top performing content patterns
      if (insights.topPerformingContent.length > 0) {
        const topTweet = insights.topPerformingContent[0];
        console.log(`üéØ TOP_PERFORMER: ${topTweet.engagementRate.toFixed(2)}% engagement - "${topTweet.content.substring(0, 50)}..."`);
        
        // Extract patterns from top performers
        insights.topPerformingContent.forEach(tweet => {
          const words = tweet.content.toLowerCase().split(' ');
          words.forEach(word => {
            if (word.length > 5 && tweet.engagementRate > insights.averageEngagement) {
              topPerformingPatterns.push(word);
            }
          });
        });

        contentHints.push(`Emulate successful patterns from top posts (${insights.averageEngagement.toFixed(1)}% avg engagement)`);
        contentHints.push(`Focus on topics similar to: "${topTweet.content.substring(0, 60)}..."`);
      }

      // Check follower growth trends
      if (recentAnalytics.profile.followers > 0) {
        contentHints.push(`Current followers: ${recentAnalytics.profile.followers} - create content for growth`);
      }

      // Set engagement targets based on recent performance
      const engagementTarget = Math.max(insights.averageEngagement * 1.2, 2.0); // Aim 20% above average, minimum 2%

      console.log(`üìà STRATEGY_GENERATED: Target ${engagementTarget.toFixed(1)}% engagement with ${contentHints.length} insights`);

      return {
        shouldPost: true, // Post if we have data insights
        contentHints,
        engagementTarget,
        topPerformingPatterns: [...new Set(topPerformingPatterns)].slice(0, 5)
      };

    } catch (error: any) {
      console.error('‚ùå DATA_STRATEGY_ERROR:', error.message);
      return {
        shouldPost: true,
        contentHints: ['Generate engaging health content with specific, actionable advice'],
        engagementTarget: 2.0,
        topPerformingPatterns: []
      };
    }
  }

  /**
   * Schedule automated analytics collection every 30 minutes
   */
  startDataCollection(): void {
    console.log('ü§ñ AUTOMATED_ANALYTICS: Starting real-time data collection...');
    this.analyticsScraper.startAutomatedCollection();
  }

  public async createEngagingPost(topic?: string): Promise<SimplePostResult> {
    if (this.isPosting) {
      return { success: false, error: 'Already posting' };
    }

    // Reset daily counter if new day
    const today = new Date().toDateString();
    if (today !== this.lastResetDate) {
      this.dailyPostCount = 0;
      this.lastResetDate = today;
    }

    // Check rate limits
    const now = Date.now();
    const timeSinceLastPost = now - this.lastPostTime;
    
    if (timeSinceLastPost < this.MIN_POST_INTERVAL) {
      const waitMinutes = Math.ceil((this.MIN_POST_INTERVAL - timeSinceLastPost) / 60000);
      return { 
        success: false, 
        error: `Rate limited. Wait ${waitMinutes} minutes` 
      };
    }

    if (this.dailyPostCount >= this.MAX_DAILY_POSTS) {
      return { 
        success: false, 
        error: 'Daily post limit reached' 
      };
    }

    this.isPosting = true;
    
    try {
      console.log('üöÄ DATA_DRIVEN_POSTING: Starting analytics-informed content creation...');
      
      // Get real-time analytics strategy
      const strategy = await this.getDataDrivenContentStrategy();
      console.log(`üìä STRATEGY_APPLIED: Target ${strategy.engagementTarget}% engagement, ${strategy.contentHints.length} insights`);
      
      logInfo('SIMPLE_POST', `Creating engaging post ${this.dailyPostCount + 1}/${this.MAX_DAILY_POSTS} with data insights`);

      // üß† LEARNING_OPTIMIZATION: Apply learned patterns to improve content
      console.log('üß† LEARNING_ENGINE: Applying performance insights...');
      const learningInsights = await this.learner.analyzeContentPerformance();
      
      console.log(`üìä LEARNING_DATA: ${learningInsights.successful_patterns.length} successful patterns found`);
      console.log(`‚ö†Ô∏è AVOIDING: ${learningInsights.failing_patterns.length} failing patterns`);
      console.log(`üí° RECOMMENDATIONS: ${learningInsights.recommendations.slice(0, 2).join(', ')}`);

      // Get content type recommendation based on learning
      const contentTypeHint = await this.learner.getImprovementSuggestions('single');
      console.log(`üéØ OPTIMAL_LENGTH: ${contentTypeHint.optimal_length} characters`);
      console.log(`üöÄ TOP_HOOKS: ${contentTypeHint.hooks.slice(0, 2).join(', ')}`);

            // üéØ DIRECT CONTENT GENERATION: Bypass broken orchestrator for variety  
      // üß† DEEP_CONTENT_DECISION: Generate detailed content with specifics  
      const shouldCreateThread = Math.random() < 0.4; // 40% chance for threads
      const contentFormat = shouldCreateThread ? 'thread' : 'single';
      console.log(`üß† DEEP_CONTENT_MODE: ${contentFormat.toUpperCase()} format - generating specific, actionable content`);
      
      // üö® FAIL-FAST: Check if we're experiencing posting issues
      const recentFailureCount = await this.getRecentFailureCount();
      let finalThreadDecision = shouldForceThread;
      if (shouldForceThread && recentFailureCount > 10) {
        console.warn(`‚ö†Ô∏è THREAD_CIRCUIT_BREAKER: ${recentFailureCount} recent failures, forcing SIMPLE tweet instead`);
        finalThreadDecision = false;
      } else if (shouldForceThread && recentFailureCount > 0) {
        console.log(`üîß THREAD_TESTING: ${recentFailureCount} recent failures, but testing thread fix...`);
      }
      
      let ultimateContent;
      
      if (finalThreadDecision) {
        console.log('üßµ DIRECT_THREAD: Using dedicated thread generator...');
        
        // Use the thread generator directly
        const { generateThread } = await import('../ai/threadGenerator');
        const { OpenAI } = await import('openai');
        const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });
        
        // üé≤ MASSIVE FORMAT VARIATION FOR LEARNING DATA
        const variations = {
          lengths: [3, 4, 5, 6, 7, 8, 10, 12], // Different thread lengths to test
          structures: ['research_deep_dive', 'protocol_walkthrough', 'myth_busting', 'personal_experiment', 'mechanism_breakdown', 'before_after', 'contrarian_take'],
          hook_types: ['shocking_stat', 'personal_story', 'contrarian_claim', 'question_based', 'direct_statement', 'research_finding'],
          spice_levels: [1, 2, 3, 4], // Intensity levels
          evidence_modes: ['research_heavy', 'anecdotal', 'mini_study', 'expert_opinion', 'data_driven']
        };
        
        // Randomly select variations for A/B testing through learning
        const targetLength = variations.lengths[Math.floor(Math.random() * variations.lengths.length)];
        const structure = variations.structures[Math.floor(Math.random() * variations.structures.length)];
        const hookType = variations.hook_types[Math.floor(Math.random() * variations.hook_types.length)];
        const spiceLevel = variations.spice_levels[Math.floor(Math.random() * variations.spice_levels.length)];
        const evidenceMode = variations.evidence_modes[Math.floor(Math.random() * variations.evidence_modes.length)];
        
        console.log(`üéØ THREAD_VARIATION_TEST: ${targetLength} tweets, ${structure}, ${hookType} hook, spice=${spiceLevel}, evidence=${evidenceMode}`);
        
        const threadContent = await generateThread({
          topic: topic || 'health optimization',
          pillar: 'health',
          angle: structure,
          spice_level: spiceLevel,
          evidence_mode: evidenceMode
        }, openai);
        
        // Convert thread to Ultimate Content format
        ultimateContent = {
          content: threadContent.tweets.map(t => t.text), // ARRAY of tweets!
          metadata: {
            type: 'thread' as const,
            generation_quality: threadContent.quality.score,
            growth_score: 85,
            viral_probability: threadContent.quality.score,
            authenticity_score: threadContent.quality.rubric.human_warmth * 20,
            learning_value: 80,
            strategic_alignment: 90,
            // üìä VARIATION TRACKING FOR LEARNING
            thread_length: targetLength,
            thread_structure: structure,
            hook_type: hookType,
            spice_level: spiceLevel,
            evidence_mode: evidenceMode,
            actual_tweets: threadContent.tweets.length
          },
          predictions: {
            likes: 25,
            retweets: 8,
            replies: 12,
            followers_gained: 3,
            engagement_rate: 4.2
          },
          strategy: {
            posting_time: 'Peak engagement hours',
            distribution_plan: 'Thread with reply chain',
            follow_up_actions: ['Engage with replies', 'Monitor thread performance']
          },
          learning: {
            what_to_track: ['Thread completion rate', 'Reply engagement'],
            success_metrics: ['High reply rate', 'Thread viral spread'],
            hypothesis: 'Health threads drive deeper engagement'
          }
        };
        
        console.log(`üßµ THREAD_GENERATED: ${ultimateContent.content.length} tweets in thread`);
        
      } else {
        console.log('üìù DIRECT_SIMPLE: Using diversified simple content generation...');
        
        // üéØ GENERATE DIVERSE SIMPLE CONTENT
        const { HookDiversificationEngine } = await import('../ai/hookDiversificationEngine');
        const { OpenAI } = await import('openai');
        
        const hookEngine = HookDiversificationEngine.getInstance();
        const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY! });
        
        // üéØ AI-DRIVEN CONTENT OPTIMIZATION: Enhanced variety and quality
        const { VariantGenerator } = await import('../content/variantGenerator');
        
        const variantGen = VariantGenerator.getInstance();
        
              // üß† DEEP_CONTENT_GENERATION: Create specific, actionable content
      const healthCategories = ['sleep', 'metabolism', 'stress', 'energy', 'supplements', 'routines'];
      const selectedCategory = healthCategories[Math.floor(Math.random() * healthCategories.length)];
      
      console.log(`üß† DEEP_CATEGORY: ${selectedCategory} with specific products/protocols`);
        
        // üß† GENERATE DEEP CONTENT WITH SPECIFIC DETAILS
        let deepContent;
        
        try {
          if (contentFormat === 'thread') {
            console.log(`üßµ GENERATING_DEEP_THREAD: ${selectedCategory} with specific products/routines`);
            deepContent = await this.deepGenerator.generateDeepContent(selectedCategory, 'thread');
            
            if (!deepContent.hasSpecificDetails) {
              console.log('‚ö†Ô∏è THREAD_LACKS_DEPTH: Regenerating with more specific requirements');
              deepContent = await this.deepGenerator.generateNighttimeRoutineThread();
            }
          } else {
            console.log(`üìù GENERATING_DEEP_SINGLE: ${selectedCategory} with specific products/protocols`);
            deepContent = await this.deepGenerator.generateProductFocusedContent(selectedCategory);
            
            if (!deepContent.hasSpecificDetails) {
              console.log('‚ö†Ô∏è CONTENT_LACKS_DEPTH: Regenerating with product focus');
              deepContent = await this.deepGenerator.generateProductFocusedContent('specific_brands');
            }
          }
          
          // Validate content depth
          const depthValidation = this.deepGenerator.validateContentDepth(deepContent.content);
          console.log(`üìä CONTENT_DEPTH_SCORE: ${depthValidation.score}/6 - ${depthValidation.isDeepEnough ? 'APPROVED' : 'NEEDS_IMPROVEMENT'}`);
          
          if (!depthValidation.isDeepEnough) {
            console.log(`‚ùå INSUFFICIENT_DEPTH: Missing ${depthValidation.missingElements.join(', ')}`);
            // Regenerate with stricter requirements
            deepContent = await this.deepGenerator.generateDeepContent(`${selectedCategory} with specific brands and protocols`, contentFormat);
          }
          
          console.log(`‚úÖ DEEP_CONTENT_GENERATED: ${deepContent.productMentions.length} products, ${deepContent.actionableSteps.length} actionable steps`);
          
        } catch (error: any) {
          console.error('‚ùå DEEP_CONTENT_ERROR:', error.message);
          // Fallback to basic deep content
          deepContent = await this.deepGenerator.generateProductFocusedContent('health_supplements');
        }
        
        // üìù PREPARE CONTENT FOR POSTING
        if (contentFormat === 'thread' && deepContent.threadParts && deepContent.threadParts.length > 1) {
          console.log(`üßµ POSTING_DEEP_THREAD: ${deepContent.threadParts.length} parts with ${deepContent.productMentions.length} specific products`);
          
          // Post as thread
          const { SimpleThreadPoster } = await import('../posting/simpleThreadPoster');
          const threadPoster = new SimpleThreadPoster();
          
          const threadResult = await threadPoster.postRealThread(deepContent.threadParts);
          
          if (threadResult.success) {
            this.dailyPostCount++;
            this.lastPostTime = Date.now();
            
            console.log(`‚úÖ DEEP_THREAD_SUCCESS: ${threadResult.tweetId} - ${deepContent.threadParts.length} tweets posted`);
            return {
              success: true,
              tweetId: threadResult.tweetId,
              content: deepContent.content,
              type: 'thread'
            };
          } else {
            console.error('‚ùå THREAD_FAILED: Falling back to single deep post');
            // Continue to single post fallback
          }
        }
        
        // üìù POST SINGLE DEEP CONTENT
        console.log(`üìù POSTING_DEEP_SINGLE: ${deepContent.productMentions.length} products mentioned`);
        const singleContent = deepContent.content.substring(0, 280);
        
        const result = await this.postTweet(singleContent);
        
        if (result.success) {
          this.dailyPostCount++;
          this.lastPostTime = Date.now();
          
          console.log(`‚úÖ DEEP_CONTENT_SUCCESS: ${result.tweetId} - Specific products: ${deepContent.productMentions.join(', ')}`);
          return {
            success: true,
            tweetId: result.tweetId,
            content: singleContent,
            type: 'single'
          };
        } else {
          console.error('‚ùå DEEP_CONTENT_FAILED: All posting attempts failed');
          
          // Fallback to original variant generation
          const bestVariant = await variantGen.generateBestVariant({
            topic: 'health',
            style: selectedCategory,
            temperature: 0.9,
            variant_count: 3
          });
          
          console.log(`üèÜ FALLBACK_VARIANT: Score=${bestVariant.total_score.toFixed(2)}, Style=${bestVariant.style}`);
          
          const result = await this.postTweet(bestVariant.content);
          
          if (result.success) {
            this.dailyPostCount++;
            this.lastPostTime = Date.now();
            return {
              success: true,
              tweetId: result.tweetId,
              content: bestVariant.content,
              type: 'single'
            };
          }
        }
        
        } catch (error: any) {
          console.error('‚ùå VARIANT_GENERATION_FAILED:', error.message);
          
          // Fallback to simple generation
          console.log('üîÑ FALLBACK: Using simple content generation...');
          const diverseHook = hookEngine.getDiverseHook('health', 'simple');
          const fallbackPrompt = `Create unique ${selectedStyle} health content that most people don't know. Include specific mechanisms, numbers, or protocols. Avoid generic advice. Under 240 chars.`;
          
          const response = await openai.chat.completions.create({
            model: 'gpt-4o',
            messages: [{ role: 'user', content: fallbackPrompt }],
            temperature: 0.8
          });
          
          bestVariant = {
            content: response.choices[0].message.content?.trim() || '',
            style: selectedStyle,
            total_score: 50
          };
        }
        
        const simpleContent = bestVariant.content;
        
        ultimateContent = {
          content: simpleContent,
          metadata: {
            type: 'single' as const,
            topic: 'health',
            angle: selectedStyle,
            quality_score: bestVariant.quality_score || 85,
            viral_prediction: bestVariant.predicted_engagement || 70,
            authenticity_score: 90,
            strategic_alignment: 85,
            generation_quality: bestVariant.total_score || 85,
            growth_score: 80,
            viral_probability: bestVariant.predicted_engagement || 70,
            // üìä SIMPLE TWEET VARIATION TRACKING
            content_style: selectedStyle,
            content_topic: 'health',
            length_target: 'medium',
            intensity_level: 'moderate',
            variant_score: bestVariant.total_score || 0
          },
          predictions: {
            likes: Math.round((bestVariant.predicted_engagement || 70) / 5),
            retweets: Math.round((bestVariant.predicted_engagement || 70) / 15),
            replies: Math.round((bestVariant.predicted_engagement || 70) / 20),
            followers_gained: Math.round((bestVariant.predicted_engagement || 70) / 25)
          },
          strategy: {
            posting_time: 'AI-optimized window',
            distribution_plan: 'Variant-selected content',
            follow_up_actions: ['Track engagement patterns', 'Update variant scoring']
          },
          learning: {
            what_to_track: ['Variant selection accuracy', 'Quality score correlation'],
            success_metrics: ['Engagement vs prediction accuracy', 'Content variety'],
            hypothesis: 'AI-driven variant testing with novelty checks maximizes engagement'
          }
        };
        
        console.log(`ü§ñ AI_OPTIMIZED_CONTENT: ${selectedStyle} health content generated via OpenAI`);
      }
      
      console.log(`üéñÔ∏è ULTIMATE_QUALITY: ${ultimateContent.metadata.generation_quality}/100`);
      console.log(`üìà GROWTH_SCORE: ${ultimateContent.metadata.growth_score}/100`);
      console.log(`üî• VIRAL_PROBABILITY: ${ultimateContent.metadata.viral_probability}/100`);
      console.log(`üß† AUTHENTICITY: ${ultimateContent.metadata.authenticity_score}/100`);
      console.log(`üìä PREDICTIONS: ${ultimateContent.predictions.likes} likes, ${ultimateContent.predictions.followers_gained} followers`);
      console.log(`‚è∞ STRATEGY: ${ultimateContent.strategy.posting_time}`);

      // üî¨ SCIENTIFIC_VALIDATION: Ensure complex content structure
      const hasScientificStructure = this.validateScientificStructure(ultimateContent.content);
      if (!hasScientificStructure) {
        logInfo('SIMPLE_POST', '‚ö†Ô∏è CONTENT_REJECTED: Not scientifically complex enough, retrying with thread format...');
        
        // IMMEDIATE RETRY: Force thread generation for scientific complexity
        console.log('üîÑ RETRY_STRATEGY: Forcing thread generation for complex scientific content...');
        const { generateThread } = await import('../ai/threadGenerator');
        const openai = new (await import('openai')).default({ apiKey: process.env.OPENAI_API_KEY! });
        
        try {
          const threadResult = await generateThread({
            topic: topic || 'health optimization breakthrough',
            pillar: 'biohacking',
            angle: 'contrarian',
            spice_level: 8,
            evidence_mode: 'mechanism'
          }, openai);
          
          // Use the thread tweets as content
          ultimateContent = {
            content: threadResult.tweets.map(t => t.text),
            metadata: { 
              viral_probability: threadResult.quality.score,
              authenticity_score: 100,
              quality_score: threadResult.quality.score
            },
            predictions: { likes: 15, followers_gained: 8 },
            strategy: { posting_time: 'Scientific thread retry' }
          };
          
          console.log(`üßµ RETRY_SUCCESS: Generated ${threadResult.tweets.length}-tweet scientific thread`);
          
        } catch (retryError: any) {
          logInfo('SIMPLE_POST', `‚ùå RETRY_FAILED: ${retryError.message}`);
          return { success: false, error: 'Failed to generate scientific content after retry' };
        }
      }
      
      // üîß IMPROVED THREAD PARSING: Handle both array and string formats
      console.log('üîß THREAD_PARSER: Analyzing content format...');
      
      let tweets: string[] = [];
      let isThreadContent = false;
      
      // Check if content is already formatted as array (from thread generator)
      if (Array.isArray(ultimateContent.content)) {
        tweets = ultimateContent.content.filter(t => t.trim());
        isThreadContent = tweets.length > 1;
        console.log(`üßµ ARRAY_FORMAT: Detected ${tweets.length} tweets in array format`);
      } 
      // Handle string content from Ultimate Content System
      else if (typeof ultimateContent.content === 'string') {
        const content = ultimateContent.content.trim();
        console.log(`üìù STRING_FORMAT: Content length ${content.length} chars`);
        
        // Method 1: Split by numbered indicators (1/, 2/, 3/, etc.)
        const numberedSplit = content.split(/\n*\d+\//).filter(t => t.trim());
        if (numberedSplit.length > 1) {
          tweets = numberedSplit.map(t => t.trim());
          isThreadContent = true;
          console.log('üßµ DETECTED: Numbered thread format');
        }
        // Method 2: Split by double newlines
        else if (content.includes('\n\n')) {
          const paragraphSplit = content.split('\n\n').filter(t => t.trim());
          if (paragraphSplit.length > 1 && paragraphSplit.every(p => p.length < 280)) {
            tweets = paragraphSplit;
            isThreadContent = true;
            console.log('üßµ DETECTED: Paragraph-based thread');
          }
        }
        
        // If no thread detected but content is long, force thread creation
        if (!isThreadContent && content.length > 250) {
          console.log('üîÑ FORCING: Long content converted to thread');
          tweets = this.splitIntoThreadTweets(content);
          isThreadContent = tweets.length > 1;
        }
        
        // Default: single tweet
        if (!isThreadContent) {
          tweets = [content];
        }
      }

      const generationResult = {
        content: {
          tweets: tweets
        },
        ultimateResult: ultimateContent // Store for learning
      };

      console.log(`üéØ ULTIMATE_POST: Generated ${isThreadContent ? 'thread' : 'single'} with ${tweets.length} tweet(s)`);
      console.log(`üìù CONTENT_PREVIEW: "${tweets[0].substring(0, 100)}${tweets[0].length > 100 ? '...' : ''}"`);
      if (isThreadContent && tweets.length > 1) {
        console.log(`üßµ THREAD_PREVIEW: Tweet 2 starts with "${tweets[1].substring(0, 50)}..."`);
      }
      
      if (!generationResult?.content?.tweets?.length) {
        throw new Error('No content generated');
      }

      // üîç QUALITY_VALIDATION: Comprehensive content quality check
      console.log('üîç QUALITY_CONTROLLER: Validating content quality...');
      
      // For threads, validate the first tweet (most critical for engagement)
      const contentToValidate = tweets[0];
      const qualityScore = await this.qualityController.validateContentQuality(contentToValidate);
      
      console.log(`üìä QUALITY_SCORE: ${qualityScore.overall}/100 (Completeness: ${qualityScore.completeness}/100)`);
      
      if (!qualityScore.shouldPost) {
        console.log('üö´ QUALITY_GATE: Content REJECTED - attempting to improve...');
        console.log('‚ùå Quality Issues:', qualityScore.issues.join(', '));
        
        // Attempt to improve the content
        const improvement = await this.qualityController.improveContent(contentToValidate, qualityScore);
        
        if (improvement.qualityIncrease > 0) {
          console.log(`‚úÖ CONTENT_IMPROVED: Quality increased by ${improvement.qualityIncrease} points`);
          tweets[0] = improvement.improvedContent;
          generationResult.content.tweets = tweets;
        } else {
          // Content couldn't be improved enough - skip posting
          return {
            success: false,
            error: `Content quality too low (${qualityScore.overall}/100): ${qualityScore.issues.join(', ')}`,
          };
        }
      } else {
        console.log('‚úÖ QUALITY_GATE: Content approved for posting');
      }

      // Handle both single tweets and threads
      const isThread = generationResult.content.tweets.length > 1;

      let postResult;
      if (isThread) {
        console.log(`üßµ SIMPLE_POST: Posting ${generationResult.content.tweets.length}-tweet thread using SIMPLE THREAD POSTER`);
        
        // Use SimpleThreadPoster for reliable thread posting
        const { SimpleThreadPoster } = await import('../posting/simpleThreadPoster');
        const threadPoster = SimpleThreadPoster.getInstance();
        
        // Validate tweets first
        const validation = threadPoster.validateTweets(generationResult.content.tweets);
        if (!validation.valid) {
          console.error('‚ùå THREAD_VALIDATION: Thread validation failed:', validation.issues.join(', '));
          throw new Error(`Thread validation failed: ${validation.issues.join(', ')}`);
        }
        
        // Optimize all tweets in the thread
        const optimizedTweets = generationResult.content.tweets.map(tweet => 
          this.optimizeForEngagement(tweet)
        );
        
        console.log('üöÄ THREAD_POSTING: Using SimpleThreadPoster for real reply chain...');
        const threadResult = await threadPoster.postRealThread(optimizedTweets);
        
        // Convert to expected format
        postResult = {
          success: threadResult.success,
          tweetId: threadResult.rootTweetId,
          replyIds: threadResult.replyIds,
          error: threadResult.error,
          method: 'simple_thread'
        };
        
        if (threadResult.success) {
          console.log(`‚úÖ THREAD_SUCCESS: Posted ${threadResult.totalTweets}-tweet thread!`);
          console.log(`üîó Root: ${threadResult.rootTweetId}, Replies: ${threadResult.replyIds?.length || 0}`);
        } else {
          this.recordFailure(); // Track failure for circuit breaker
          console.error(`‚ùå THREAD_FAILURE: ${threadResult.error}`);
        }
        
      } else {
        console.log('üìù SIMPLE_POST: Posting single tweet');
        
        // Get the single tweet content
      const tweetContent = generationResult.content.tweets[0];
      if (!tweetContent) {
        throw new Error('No tweet content generated');
      }

      // üîç FINAL NOVELTY CHECK FOR AI-OPTIMIZED CONTENT
      console.log('üéØ AI_CONTENT: Checking novelty for variant-optimized content...');
      try {
        const { NoveltyGuard } = await import('../content/noveltyGuard');
        const noveltyGuard = NoveltyGuard.getInstance();
        
        const noveltyCheck = await noveltyGuard.checkNovelty(tweetContent);
        
        if (!noveltyCheck.is_novel) {
          console.log(`‚ùå NOVELTY_REJECTED: ${noveltyCheck.rejection_reason}`);
          console.log(`üìä Similarity scores: Jaccard=${noveltyCheck.jaccard_similarity?.toFixed(3)}, Levenshtein=${noveltyCheck.levenshtein_similarity?.toFixed(3)}`);
          // Don't throw error, just warn for now
          console.warn('‚ö†Ô∏è Content may be similar to previous posts but proceeding...');
        } else {
          console.log('‚úÖ NOVELTY_APPROVED: Content is unique');
        }
      } catch (noveltyError: any) {
        console.warn('‚ö†Ô∏è NOVELTY_CHECK_FAILED:', noveltyError.message);
      }

      // Optimize for engagement
      const optimizedContent = this.optimizeForEngagement(tweetContent);
      
      // Post to Twitter using the postSingleTweet method
      const poster = new TwitterPoster();
        postResult = await poster.postSingleTweet(optimizedContent);
      }
      
      if (!postResult.success || !postResult.tweetId) {
        throw new Error(postResult.error || 'Failed to post to Twitter');
      }

      // Track metrics immediately
      await scheduleMetricsTracking(postResult.tweetId);
      
      // Store for learning with correct format tracking
      const contentForStorage = isThread ? 
        (postResult as any).allTweets?.join('\n\n') || generationResult.content.tweets.join('\n\n') :
        (postResult as any).content || generationResult.content.tweets[0];
        
      await storeLearningPost({
        content: contentForStorage,
        tweet_id: postResult.tweetId,
        quality_score: 85 // Ultimate system has built-in quality gates
      });

      // Update counters
      this.lastPostTime = now;
      this.dailyPostCount++;

      logInfo('SIMPLE_POST', `‚úÖ Posted ${isThread ? 'thread' : 'single tweet'} successfully: ${postResult.tweetId}`);
      logInfo('SIMPLE_POST', `üìä Daily posts: ${this.dailyPostCount}/${this.MAX_DAILY_POSTS}`);

              // Store ultimate content result for learning
        const ultimateResult = (generationResult as any).ultimateResult;
        if (ultimateResult) {
          try {
            // Store the ultimate content data for future learning
            await this.storeUltimateContentData(postResult.tweetId, ultimateResult);
            
            // ü§ñ AI SYSTEM INTEGRATION: Register with novelty guard
            console.log('üéØ POST_SUCCESS_INTEGRATION: Setting up AI learning systems...');
            
            try {
              // Register content with novelty guard
              const { NoveltyGuard } = await import('../content/noveltyGuard');
              const noveltyGuard = NoveltyGuard.getInstance();
              await noveltyGuard.registerContent(postResult.tweetId, contentForStorage);
              
              console.log(`üìä NOVELTY_REGISTERED: Content fingerprint stored for ${postResult.tweetId}`);
            } catch (noveltyError: any) {
              console.warn('‚ö†Ô∏è NOVELTY_REGISTRATION_FAILED:', noveltyError.message);
            }
            
          } catch (error) {
            console.warn('‚ö†Ô∏è Failed to store ultimate content data:', error);
          }
        }

      return {
        success: true,
        tweetId: postResult.tweetId,
          content: contentForStorage,
          engagementPrediction: ultimateResult?.predictions?.likes || 5
      };

    } catch (error: any) {
      logError('SIMPLE_POST', `‚ùå Failed to create post: ${error.message}`);
      return {
        success: false,
        error: error.message
      };
    } finally {
      this.isPosting = false;
    }
  }

  /**
   * Build prompt optimized for engagement
   */
  private buildEngagementOptimizedPrompt(topic?: string): string {
    const basePrompt = `Create a highly engaging health/wellness tweet that will get likes, retweets, and replies.

ENGAGEMENT REQUIREMENTS:
- Start with an attention-grabbing hook (shocking stat, surprising fact, or bold claim)
- Include specific numbers or percentages 
- Make it controversial but defensible
- End with a question or call-to-action
- Use 1-2 relevant emojis maximum
- Keep under 250 characters
- Make people want to share it

CONTENT FOCUS: ${topic || 'breakthrough health research, wellness tips, or medical innovations'}

EXAMPLES OF HIGH-ENGAGEMENT PATTERNS:
- "97% of people don't know this about [health topic]..."
- "[Shocking statistic] about [common health belief] - here's why..."
- "Doctors hate this simple [health hack] that [specific benefit]..."

Create content that makes people stop scrolling and engage.`;

    return basePrompt;
  }

  /**
   * üîß SPLIT LONG CONTENT INTO THREAD TWEETS
   */
  private splitIntoThreadTweets(content: string): string[] {
    const maxTweetLength = 250; // Safe limit
    const tweets: string[] = [];
    
    // Split by sentences first
    const sentences = content.split(/(?<=[.!?])\s+/);
    let currentTweet = '';
    
    for (const sentence of sentences) {
      // If adding this sentence would exceed limit, start new tweet
      if (currentTweet && (currentTweet + ' ' + sentence).length > maxTweetLength) {
        if (currentTweet.trim()) {
          tweets.push(currentTweet.trim());
          currentTweet = sentence;
        }
      } else {
        currentTweet = currentTweet ? currentTweet + ' ' + sentence : sentence;
      }
    }
    
    // Add the last tweet
    if (currentTweet.trim()) {
      tweets.push(currentTweet.trim());
    }
    
    // If we only got one tweet and it's still too long, split by words
    if (tweets.length === 1 && tweets[0].length > maxTweetLength) {
      return this.splitByWords(tweets[0], maxTweetLength);
    }
    
    console.log(`üìù SPLIT_RESULT: ${content.length} chars ‚Üí ${tweets.length} tweets`);
    return tweets;
  }

  /**
   * üîß EMERGENCY WORD SPLITTING for very long content
   */
  private splitByWords(content: string, maxLength: number): string[] {
    const words = content.split(' ');
    const tweets: string[] = [];
    let currentTweet = '';
    
    for (const word of words) {
      if (currentTweet && (currentTweet + ' ' + word).length > maxLength) {
        tweets.push(currentTweet.trim());
        currentTweet = word;
      } else {
        currentTweet = currentTweet ? currentTweet + ' ' + word : word;
      }
    }
    
    if (currentTweet.trim()) {
      tweets.push(currentTweet.trim());
    }
    
    return tweets;
  }

  /**
   * Optimize content for maximum engagement
   */
  private optimizeForEngagement(content: string): string {
    let optimized = content.trim();

    // Ensure it has engagement triggers
    const engagementTriggers = [
      /\d+%/, // Percentages
      /\$\d+/, // Dollar amounts
      /\d+x/, // Multipliers
      /\d+ (minutes?|hours?|days?|weeks?|months?)/, // Time periods
      /\?$/, // Questions
      /\!$/, // Exclamations
    ];

    const hasEngagementTrigger = engagementTriggers.some(trigger => trigger.test(optimized));
    
    if (!hasEngagementTrigger && !optimized.includes('?')) {
      // Add a question to increase engagement
      optimized += '\n\nThoughts?';
    }

    // Ensure proper length (Twitter sweet spot is 71-100 characters for engagement)
    if (optimized.length > 250) {
      optimized = optimized.substring(0, 247) + '...';
    }

    return optimized;
  }

  /**
   * Store ultimate content data for future learning
   */
  private async storeUltimateContentData(tweetId: string, ultimateResult: any): Promise<void> {
    try {
      // Store in a dedicated table or enhance existing storage
      console.log(`üìö STORING_ULTIMATE_DATA: ${tweetId} with ${ultimateResult.metadata.generation_quality}/100 quality`);
      
      // You could store this in a dedicated database table for advanced analytics
      // For now, we'll log the key metrics
      console.log(`üéØ STORED_METRICS: Growth ${ultimateResult.metadata.growth_score}/100, Viral ${ultimateResult.metadata.viral_probability}/100`);
      
    } catch (error) {
      console.error('‚ùå Failed to store ultimate content data:', error);
    }
  }

  /**
   * Predict engagement potential (0-100)
   */
  private predictEngagement(content: string): number {
    let score = 50; // Base score

    // Check for engagement factors
    if (/\d+%/.test(content)) score += 15; // Has percentage
    if (/\?/.test(content)) score += 10; // Has question
    if (/\!/.test(content)) score += 5; // Has exclamation
    if (content.length >= 71 && content.length <= 100) score += 10; // Optimal length
    if (/\b(shocking|surprising|breakthrough|secret|hidden)\b/i.test(content)) score += 10; // Power words
    if (/\$\d+/.test(content)) score += 8; // Has money amount
    if (/\d+x/.test(content)) score += 8; // Has multiplier

    return Math.min(100, Math.max(0, score));
  }

  /**
   * Get current status
   */
  public getStatus() {
    return {
      isPosting: this.isPosting,
      dailyPostCount: this.dailyPostCount,
      maxDailyPosts: this.MAX_DAILY_POSTS,
      lastPostTime: this.lastPostTime,
      canPostNow: !this.isPosting && 
                  (Date.now() - this.lastPostTime) >= this.MIN_POST_INTERVAL &&
                  this.dailyPostCount < this.MAX_DAILY_POSTS
    };
  }

  /**
   * Validate that content has complex scientific structure
   */
  private validateScientificStructure(content: any): boolean {
    const text = Array.isArray(content) ? content.join(' ') : content;
    if (!text || typeof text !== 'string') return false;
    
    // Check for complex scientific elements from user's example
    const scientificIndicators = [
      /\d+\s*(¬∞F|¬∞C|mg|hours?|minutes?|%)/i, // Specific numbers with units
      /(due to|because|activates?|triggers?|suppresses?)/i, // Causal mechanisms  
      /(REM|GABA|melatonin|cortisol|dopamine|serotonin)/i, // Scientific terms
      /\d+\s*ways? to/i, // Structured format "X ways to"
      /(crucial|essential) for .* due to/i, // Causal connections
    ];
    
    const matches = scientificIndicators.filter(pattern => pattern.test(text)).length;
    const hasComplexStructure = matches >= 3; // Need at least 3 scientific elements
    
    console.log(`üî¨ SCIENTIFIC_VALIDATION: Found ${matches}/5 scientific indicators`);
    return hasComplexStructure;
  }

  /**
   * Track recent failures for circuit breaker logic
   */
  private async getRecentFailureCount(): Promise<number> {
    const oneHourAgo = Date.now() - (60 * 60 * 1000);
    // Remove old failures
    this.recentFailures = this.recentFailures.filter(timestamp => timestamp > oneHourAgo);
    return this.recentFailures.length;
  }

  /**
   * Record a posting failure for circuit breaker
   */
  private recordFailure(): void {
    this.recentFailures.push(Date.now());
    console.log(`‚ö†Ô∏è FAILURE_RECORDED: ${this.recentFailures.length} failures in last hour`);
  }
}
