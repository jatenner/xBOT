import { OpenAI } from "openai";
import { NutritionData, NutritionixFood, NutrientInfo, createNutrientAnalysis } from './nutritionixApi';
import { GPT_MODEL } from './constants';

// Extend the NutritionData interface to include source information
export interface ExtendedNutritionData extends NutritionData {
  source: 'gpt' | 'nutritionix' | 'gpt_fallback' | 'gpt_error';
}

/**
 * Generate nutrition data using GPT when Nutritionix API fails
 * Includes better timeout handling and error logging
 * Always returns a valid object with all required fields for storage
 * @param foodDescription Description of food to analyze
 * @param requestId Request identifier for tracking
 * @returns Nutritional data generated by GPT, always returns a valid object
 */
export async function callGptNutritionFallback(
  foodDescription: string,
  requestId: string
): Promise<NutritionData> {
  console.time(`‚è±Ô∏è [${requestId}] GPT nutrition fallback`);
  console.log(`ü§ñ [${requestId}] Calling GPT nutrition fallback for: ${foodDescription}`);
  
  // Ensure we have a valid food description
  const safeDescription = foodDescription || "Unknown meal";
  
  // Define default nutrients to use in case of error - never return empty array
  const defaultNutrients: NutrientInfo[] = [
    { name: 'Calories', value: 500, unit: 'kcal', isHighlight: true },
    { name: 'Protein', value: 15, unit: 'g', isHighlight: true },
    { name: 'Carbs', value: 40, unit: 'g', isHighlight: true },
    { name: 'Fat', value: 20, unit: 'g', isHighlight: true },
    { name: 'Fiber', value: 3, unit: 'g', isHighlight: false },
    { name: 'Sugar', value: 10, unit: 'g', isHighlight: false },
    { name: 'Sodium', value: 500, unit: 'mg', isHighlight: false },
  ];

  // Create default feedback and suggestions
  const defaultFeedback = [
    "This meal contains a mix of macronutrients.",
    "We provided estimated nutrition values as a fallback."
  ];
  
  const defaultSuggestions = [
    "Consider balancing your meal with vegetables for more micronutrients.",
    "Stay hydrated by drinking water with your meal."
  ];

  // Default goal score
  const defaultGoalScore = {
    overall: 5,
    specific: { 'General Health': 5 }
  };

  // Create a mock NutritionixFood object that matches the required interface
  const mockFood: NutritionixFood = {
    food_name: safeDescription,
    serving_qty: 1,
    serving_unit: 'serving',
    serving_weight_grams: 100,
    nf_calories: 500,
    nf_total_fat: 20,
    nf_saturated_fat: 5,
    nf_cholesterol: 50,
    nf_sodium: 500,
    nf_total_carbohydrate: 40,
    nf_dietary_fiber: 3,
    nf_sugars: 10,
    nf_protein: 15,
    nf_potassium: 300,
    nf_p: 100,
    full_nutrients: [],
    photo: {
      thumb: '',
      highres: '',
      is_user_uploaded: false
    }
  };
  
  // Set timeout for OpenAI request (8 seconds)
  const timeoutMs = 8000;
  
  try {
    // Validate OpenAI API Key
    const apiKey = process.env.OPENAI_API_KEY;
    if (!apiKey) {
      throw new Error('OpenAI API key is not configured');
    }
    
    // Initialize OpenAI client
    const openai = new OpenAI({
      apiKey: apiKey,
    });

    const timeoutPromise = new Promise<null>((_, reject) => {
      setTimeout(() => {
        reject(new Error('GPT nutrition request timed out'));
      }, timeoutMs);
    });

    // Setup the API request
    const apiPromise = openai.chat.completions.create({
      model: "gpt-4o",
      messages: [
        {
          role: "system",
          content: "You are a nutrition expert who extracts accurate nutrition information from food descriptions. Provide nutrition data in JSON format."
        },
        {
          role: "user",
          content: `Extract nutritional information for: ${safeDescription}. Return ONLY a JSON object with these fields: description (brief description of the food), calories (kcal), protein (g), carbs (g), fat (g), fiber (g), sugar (g), sodium (mg). Use numeric values only for nutrients. Include a 'feedback' array with 2-3 short nutritional insights and a 'suggestions' array with 1-2 dietary recommendations.`
        }
      ],
      response_format: { type: "json_object" },
      temperature: 0.2,
    });

    // Race between the API call and timeout
    console.log(`‚è≥ [${requestId}] Waiting for GPT nutrition response (timeout: ${timeoutMs}ms)`);
    const startTime = Date.now();
    
    // @ts-ignore
    const response = await Promise.race([apiPromise, timeoutPromise]);
    
    const endTime = Date.now();
    console.log(`‚åõ [${requestId}] GPT nutrition response received in ${endTime - startTime}ms`);

    if (response) {
      // Parse response content
      try {
        // Always provide a fallback for empty or invalid responses
        const responseText = response.choices[0]?.message?.content || "{}";
        let nutritionData;
        
        try {
          nutritionData = JSON.parse(responseText);
        } catch (jsonError) {
          console.error(`‚ùå [${requestId}] Invalid JSON response from GPT:`, responseText);
          nutritionData = {};
        }
        
        // Extract description (fallback if not provided)
        const description = nutritionData.description || safeDescription || "Unknown meal";
        
        // Create a structured response format - always use fallbacks for each nutrient
        const nutrients: NutrientInfo[] = [
          { name: 'Calories', value: nutritionData.calories || 500, unit: 'kcal', isHighlight: true },
          { name: 'Protein', value: nutritionData.protein || 15, unit: 'g', isHighlight: true },
          { name: 'Carbs', value: nutritionData.carbs || 40, unit: 'g', isHighlight: true },
          { name: 'Fat', value: nutritionData.fat || 20, unit: 'g', isHighlight: true },
          { name: 'Fiber', value: nutritionData.fiber || 3, unit: 'g', isHighlight: false },
          { name: 'Sugar', value: nutritionData.sugar || 10, unit: 'g', isHighlight: false },
          { name: 'Sodium', value: nutritionData.sodium || 500, unit: 'mg', isHighlight: false },
        ];

        // Extract feedback and suggestions from response or use defaults
        const feedback = Array.isArray(nutritionData.feedback) && nutritionData.feedback.length > 0
          ? nutritionData.feedback
          : defaultFeedback;
        
        const suggestions = Array.isArray(nutritionData.suggestions) && nutritionData.suggestions.length > 0
          ? nutritionData.suggestions
          : defaultSuggestions;

        // Check if we have valid nutrition data
        const hasValidNutritionData = 
          nutritionData.calories !== undefined || 
          nutritionData.protein !== undefined ||
          nutritionData.carbs !== undefined ||
          nutritionData.fat !== undefined;

        // Create a food item with the extracted nutrition data
        const food: NutritionixFood = {
          food_name: description,
          serving_qty: 1,
          serving_unit: 'serving',
          serving_weight_grams: 100,
          nf_calories: nutritionData.calories || 500,
          nf_total_fat: nutritionData.fat || 20,
          nf_saturated_fat: nutritionData.fat ? nutritionData.fat / 4 : 5,
          nf_cholesterol: 50,
          nf_sodium: nutritionData.sodium || 500,
          nf_total_carbohydrate: nutritionData.carbs || 40,
          nf_dietary_fiber: nutritionData.fiber || 3,
          nf_sugars: nutritionData.sugar || 10,
          nf_protein: nutritionData.protein || 15,
          nf_potassium: 300,
          nf_p: 100,
          full_nutrients: [],
          photo: {
            thumb: '',
            highres: '',
            is_user_uploaded: false
          }
        };

        // Determine source based on completeness of response
        const source = hasValidNutritionData ? 'gpt' : 'gpt_fallback';
        
        if (!hasValidNutritionData) {
          console.warn(`‚ö†Ô∏è [${requestId}] GPT returned incomplete nutrition data, using fallback values`);
        } else {
          console.log(`‚úÖ [${requestId}] Successfully generated nutrition data with GPT`);
        }
        
        console.timeEnd(`‚è±Ô∏è [${requestId}] GPT nutrition fallback`);
        
        const successResponse = {
          nutrients,
          foods: [food],
          raw: {
            description,
            feedback,
            suggestions,
            goalScore: defaultGoalScore,
            model: response.model,
            promptTokens: response.usage?.prompt_tokens,
            completionTokens: response.usage?.completion_tokens,
            response: responseText,
            source,
            error: hasValidNutritionData ? null : 'Incomplete nutrition data',
            fallback: !hasValidNutritionData
          }
        };
        
        // Debug log to confirm response structure
        console.log(`[${requestId}] GPT_SUCCESS_STRUCTURE:`, JSON.stringify({
          has_nutrients: Array.isArray(successResponse.nutrients) && successResponse.nutrients.length > 0,
          has_foods: Array.isArray(successResponse.foods) && successResponse.foods.length > 0,
          has_raw_description: Boolean(successResponse.raw?.description),
          has_raw_feedback: Array.isArray(successResponse.raw?.feedback) && successResponse.raw?.feedback.length > 0,
          has_raw_suggestions: Array.isArray(successResponse.raw?.suggestions) && successResponse.raw?.suggestions.length > 0,
          source: successResponse.raw?.source,
          nutrients_length: successResponse.nutrients?.length || 0
        }));
        
        // Debug the FINAL success structure being returned
        console.log("FINAL FALLBACK SUCCESS", successResponse);
        
        // Final validation to ensure critical fields
        if (!Array.isArray(successResponse.nutrients) || successResponse.nutrients.length === 0) {
          console.error(`[${requestId}] CRITICAL: Missing nutrients in GPT success response, adding default nutrients`);
          successResponse.nutrients = [
            { name: 'Calories', value: 500, unit: 'kcal', isHighlight: true },
            { name: 'Protein', value: 15, unit: 'g', isHighlight: true },
            { name: 'Carbs', value: 40, unit: 'g', isHighlight: true },
            { name: 'Fat', value: 20, unit: 'g', isHighlight: true }
          ];
        }
        
        // Ensure raw has a valid description 
        if (!successResponse.raw?.description || typeof successResponse.raw.description !== 'string') {
          console.error(`[${requestId}] CRITICAL: Missing description in GPT success response, adding default description`);
          successResponse.raw.description = "Food item";
        }
        
        console.log(`üí• Final fallback result:`, JSON.stringify({
          has_nutrients: Array.isArray(successResponse.nutrients) && successResponse.nutrients.length > 0,
          nutrients_count: successResponse.nutrients.length,
          has_foods: Array.isArray(successResponse.foods) && successResponse.foods.length > 0,
          foods_count: successResponse.foods.length,
          has_raw: !!successResponse.raw,
          has_raw_description: !!successResponse.raw?.description,
          raw_description: successResponse.raw?.description?.substring(0, 30),
          source: (successResponse as any).source || 'unknown'
        }, null, 2));
        
        return successResponse;
      } catch (parseError: any) {
        console.error(`‚ùå [${requestId}] Failed to parse GPT nutrition response:`, parseError);
        console.error(`‚ùå [${requestId}] Raw response:`, response.choices[0]?.message?.content);
      }
    }
  } catch (error: any) {
    const errorMessage = error.message || 'Unknown error';
    console.error(`‚ùå [${requestId}] Error in GPT nutrition fallback:`, errorMessage);
    
    if (errorMessage.includes('timed out')) {
      console.error(`‚è±Ô∏è [${requestId}] GPT nutrition request timed out after ${timeoutMs}ms`);
    }
  }
  
  console.log(`‚ö†Ô∏è [${requestId}] Using default nutrition values due to GPT fallback error`);
  console.timeEnd(`‚è±Ô∏è [${requestId}] GPT nutrition fallback`);
  
  // Create a descriptive fallback message based on the input
  const fallbackDescription = 
    safeDescription === "Unknown meal" 
      ? "Unable to analyze this meal" 
      : `This appears to be ${safeDescription}. Unable to provide detailed analysis.`;
  
  // Return default values in case of any error - ensure we always have all required fields
  const fallbackResponse = {
    nutrients: defaultNutrients,
    foods: [mockFood], // Always include at least one food item
    raw: {
      description: fallbackDescription,
      feedback: defaultFeedback,
      suggestions: defaultSuggestions,
      goalScore: defaultGoalScore,
      source: 'gpt_error',
      error: 'Error generating nutrition data',
      fallback: true
    },
    source: 'gpt_error'  // Add source at top level for frontend compatibility
  };
  
  // CRITICAL: Ensure nutrients are in the proper format (object with name, value, unit, isHighlight)
  if (!Array.isArray(fallbackResponse.nutrients) || fallbackResponse.nutrients.length === 0) {
    console.warn(`[${requestId}] CRITICAL: Missing nutrients array in GPT fallback, adding default nutrients`);
    fallbackResponse.nutrients = [
      { name: 'Calories', value: 500, unit: 'kcal', isHighlight: true },
      { name: 'Protein', value: 15, unit: 'g', isHighlight: true },
      { name: 'Carbs', value: 40, unit: 'g', isHighlight: true },
      { name: 'Fat', value: 20, unit: 'g', isHighlight: true }
    ];
  }
  
  // Ensure each nutrient has the required properties
  fallbackResponse.nutrients = fallbackResponse.nutrients.map(nutrient => {
    if (typeof nutrient !== 'object' || nutrient === null) {
      return { name: 'Unknown', value: 0, unit: 'g', isHighlight: false };
    }
    
    return {
      name: nutrient.name || 'Unknown',
      value: nutrient.value !== undefined ? nutrient.value : 0,
      unit: nutrient.unit || 'g',
      isHighlight: nutrient.isHighlight !== undefined ? nutrient.isHighlight : false
    };
  });
  
  // Ensure raw object has a description
  if (!fallbackResponse.raw.description || typeof fallbackResponse.raw.description !== 'string') {
    console.warn(`[${requestId}] CRITICAL: Missing description in GPT fallback, adding default description`);
    fallbackResponse.raw.description = "Could not analyze this meal properly.";
  }
  
  // Ensure raw object has feedback array
  if (!Array.isArray(fallbackResponse.raw.feedback) || fallbackResponse.raw.feedback.length === 0) {
    console.warn(`[${requestId}] CRITICAL: Missing feedback in GPT fallback, adding default feedback`);
    fallbackResponse.raw.feedback = ["Unable to analyze the image."];
  }
  
  // Ensure raw object has suggestions array
  if (!Array.isArray(fallbackResponse.raw.suggestions) || fallbackResponse.raw.suggestions.length === 0) {
    console.warn(`[${requestId}] CRITICAL: Missing suggestions in GPT fallback, adding default suggestions`);
    fallbackResponse.raw.suggestions = ["Try a clearer photo with more lighting."];
  }
  
  // Debug log to verify fallback structure
  console.log(`[${requestId}] GPT_ERROR_FALLBACK_STRUCTURE:`, JSON.stringify({
    has_nutrients: Array.isArray(fallbackResponse.nutrients) && fallbackResponse.nutrients.length > 0,
    has_foods: Array.isArray(fallbackResponse.foods) && fallbackResponse.foods.length > 0,
    has_raw: Boolean(fallbackResponse.raw),
    has_raw_description: Boolean(fallbackResponse.raw?.description),
    description_type: typeof fallbackResponse.raw?.description,
    has_raw_feedback: Array.isArray(fallbackResponse.raw?.feedback) && fallbackResponse.raw?.feedback.length > 0, 
    has_raw_suggestions: Array.isArray(fallbackResponse.raw?.suggestions) && fallbackResponse.raw?.suggestions.length > 0,
    has_source: Boolean(fallbackResponse.source),
    source: fallbackResponse.source,
    nutrients_length: fallbackResponse.nutrients?.length || 0
  }));
  
  // Debug the FINAL structure being returned
  console.log(`[${requestId}] FINAL_GPT_FALLBACK:`, JSON.stringify({
    nutrients_length: fallbackResponse.nutrients.length,
    foods_length: fallbackResponse.foods.length,
    raw_description: Boolean(fallbackResponse.raw.description),
    raw_feedback: Boolean(fallbackResponse.raw.feedback),
    raw_suggestions: Boolean(fallbackResponse.raw.suggestions),
    source: fallbackResponse.source
  }));
  
  // Final validation to ensure critical fields exist
  if (!Array.isArray(fallbackResponse.nutrients) || fallbackResponse.nutrients.length === 0) {
    console.error(`[${requestId}] CRITICAL: Final validation - missing nutrients in GPT fallback, adding default nutrients`);
    fallbackResponse.nutrients = [
      { name: 'Calories', value: 500, unit: 'kcal', isHighlight: true },
      { name: 'Protein', value: 15, unit: 'g', isHighlight: true },
      { name: 'Carbs', value: 40, unit: 'g', isHighlight: true },
      { name: 'Fat', value: 20, unit: 'g', isHighlight: true }
    ];
  }
  
  console.log(`üí• Final fallback result:`, JSON.stringify({
    has_nutrients: Array.isArray(fallbackResponse.nutrients) && fallbackResponse.nutrients.length > 0,
    nutrients_count: fallbackResponse.nutrients.length,
    has_foods: Array.isArray(fallbackResponse.foods) && fallbackResponse.foods.length > 0,
    foods_count: fallbackResponse.foods.length,
    has_raw: !!fallbackResponse.raw,
    has_raw_description: !!fallbackResponse.raw?.description,
    raw_description: fallbackResponse.raw?.description?.substring(0, 30),
    source: fallbackResponse.source || 'unknown'
  }, null, 2));
  
  return fallbackResponse;
} 