/**
 * Generate TypeScript types from actual database schema
 * 
 * Run: npx ts-node scripts/generateDatabaseTypes.ts
 * 
 * This will:
 * 1. Connect to your Supabase database
 * 2. Read the actual column types
 * 3. Generate TypeScript interfaces
 * 4. Save to src/types/database.ts
 */

import { getSupabaseClient } from '../src/lib/supabaseClient';
import * as fs from 'fs';
import * as path from 'path';

const TABLES_TO_GENERATE = [
  'content_metadata',
  'posted_decisions',
  'outcomes',
  'reply_opportunities',
  'discovered_accounts',
  'content_violations',
  'post_attribution'
];

const VIEWS_TO_GENERATE = [
  'content_with_outcomes'
];

// Map PostgreSQL types to TypeScript types
const TYPE_MAP: Record<string, string> = {
  'bigint': 'number',
  'integer': 'number',
  'smallint': 'number',
  'numeric': 'number',
  'real': 'number',
  'double precision': 'number',
  'text': 'string',
  'character varying': 'string',
  'varchar': 'string',
  'char': 'string',
  'boolean': 'boolean',
  'timestamp with time zone': 'string', // ISO date string
  'timestamp without time zone': 'string',
  'timestamptz': 'string',
  'date': 'string',
  'json': 'any',
  'jsonb': 'any',
  'uuid': 'string',
  'USER-DEFINED': 'string' // Enums
};

async function generateTypes() {
  console.log('üîß Generating TypeScript types from database schema...\n');

  const supabase = getSupabaseClient();
  let output = `/**
 * AUTO-GENERATED DATABASE TYPES
 * 
 * Generated: ${new Date().toISOString()}
 * 
 * DO NOT EDIT THIS FILE MANUALLY!
 * Run: npm run generate:types
 */

`;

  // Generate table types
  for (const tableName of TABLES_TO_GENERATE) {
    console.log(`üìã Generating type for table: ${tableName}`);
    
    try {
      const { data, error } = await supabase
        .from(tableName)
        .select('*')
        .limit(1);

      if (error) {
        console.error(`   ‚ùå Error: ${error.message}`);
        continue;
      }

      if (!data || data.length === 0) {
        // Table exists but is empty - query column info directly
        const { data: sample } = await supabase
          .from(tableName)
          .select('*')
          .limit(0);
        
        if (sample !== null) {
          console.warn(`   ‚ö†Ô∏è  Table is empty, generating minimal type`);
          output += generateInterfaceFromEmpty(tableName);
          continue;
        }
      }

      const sample = data[0];
      const interfaceName = toPascalCase(tableName);
      
      output += `export interface ${interfaceName} {\n`;
      
      for (const [key, value] of Object.entries(sample)) {
        const tsType = inferType(value);
        const optional = value === null ? '?' : '';
        output += `  ${key}${optional}: ${tsType};\n`;
      }
      
      output += `}\n\n`;
      
      console.log(`   ‚úÖ Generated ${interfaceName}`);
      
    } catch (err: any) {
      console.error(`   ‚ùå Failed: ${err.message}`);
    }
  }

  // Generate view types
  for (const viewName of VIEWS_TO_GENERATE) {
    console.log(`üëÅÔ∏è  Generating type for view: ${viewName}`);
    
    try {
      const { data, error } = await supabase
        .from(viewName)
        .select('*')
        .limit(1);

      if (error) {
        console.error(`   ‚ùå Error: ${error.message}`);
        continue;
      }

      if (!data || data.length === 0) {
        console.warn(`   ‚ö†Ô∏è  View is empty, skipping`);
        continue;
      }

      const sample = data[0];
      const interfaceName = toPascalCase(viewName);
      
      output += `export interface ${interfaceName} {\n`;
      
      for (const [key, value] of Object.entries(sample)) {
        const tsType = inferType(value);
        const optional = value === null ? '?' : '';
        output += `  ${key}${optional}: ${tsType};\n`;
      }
      
      output += `}\n\n`;
      
      console.log(`   ‚úÖ Generated ${interfaceName}`);
      
    } catch (err: any) {
      console.error(`   ‚ùå Failed: ${err.message}`);
    }
  }

  // Add helper types
  output += `// Helper types\n`;
  output += `export type Database = {\n`;
  for (const tableName of TABLES_TO_GENERATE) {
    const interfaceName = toPascalCase(tableName);
    output += `  ${tableName}: ${interfaceName};\n`;
  }
  output += `};\n\n`;

  output += `export type Views = {\n`;
  for (const viewName of VIEWS_TO_GENERATE) {
    const interfaceName = toPascalCase(viewName);
    output += `  ${viewName}: ${interfaceName};\n`;
  }
  output += `};\n`;

  // Write to file
  const outputPath = path.join(__dirname, '../src/types/database.ts');
  fs.mkdirSync(path.dirname(outputPath), { recursive: true });
  fs.writeFileSync(outputPath, output);

  console.log(`\n‚úÖ Types generated successfully!`);
  console.log(`üìÅ Output: ${outputPath}`);
}

function toPascalCase(str: string): string {
  return str
    .split('_')
    .map(word => word.charAt(0).toUpperCase() + word.slice(1))
    .join('');
}

function inferType(value: any): string {
  if (value === null || value === undefined) {
    return 'any'; // Unknown type
  }

  const jsType = typeof value;
  
  if (jsType === 'string') return 'string';
  if (jsType === 'number') return 'number';
  if (jsType === 'boolean') return 'boolean';
  if (Array.isArray(value)) return 'any[]';
  if (jsType === 'object') return 'any'; // JSON
  
  return 'any';
}

function generateInterfaceFromEmpty(tableName: string): string {
  const interfaceName = toPascalCase(tableName);
  return `export interface ${interfaceName} {\n  [key: string]: any; // Table is empty, cannot infer types\n}\n\n`;
}

// Run if called directly
if (require.main === module) {
  generateTypes()
    .then(() => process.exit(0))
    .catch((error) => {
      console.error('‚ùå Fatal error:', error);
      process.exit(1);
    });
}

